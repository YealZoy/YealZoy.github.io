[{"title":"javascript","date":"2019-03-04T12:13:02.000Z","path":"201903/04/javascript/","text":"javascrip简介javascript实现 ecmascript 语法 类型 语句 关键字 保留字 操作符 对象 dom dom视图 dom事件 dom样式 bom 弹出浏览器 移动，缩放，关闭浏览器 navigator location screen cookie XMLHttpRequest(ActiveXObject) script属性 async 可选 表示立即下载脚本，不妨碍页面中其他操作，只对外部脚本文件有效 charset 可选 defer 可选 表示脚本可以延迟到文档完全被解析和显示之后再执行，只对外部脚本文件有效 language 已废弃 src 可选。表示包含要执行代码的外部文件 type 可选 html文档模式 混杂模式(quirks mode) 标准模式(standards mode) 准标准模 式(almost standards mode)&lt;!--标准模式--&gt;&lt;!-- HTML 4.01 严格型 --&gt;&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"&gt;&lt;!-- XHTML 1.0 严格型 --&gt;&lt;!DOCTYPE html PUBLIC\"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"&gt;&lt;!-- HTML 5 --&gt;&lt;!DOCTYPE html&gt;&lt;!--准标准模式 而对于准标准模式，则可以通过使用过渡型(transitional)或框架集型(frameset)文档类型来触发--&gt;&lt;!-- HTML 4.01 过渡型 --&gt;&lt;!DOCTYPE HTML PUBLIC\"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt; &lt;!-- HTML 4.01 框架集型 --&gt;&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\"\"http://www.w3.org/TR/html4/frameset.dtd\"&gt; &lt;!-- XHTML 1.0 过渡型 --&gt;&lt;!DOCTYPE html PUBLIC\"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;!-- XHTML 1.0 框架集型 --&gt;&lt;!DOCTYPE html PUBLIC\"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\"&gt; ecmascript严格模式在顶部或函数体首行&quot;use strict&quot;; 数据类型 number string null undefined boolean typeof操作符 “undefined” 如果这个值未定义; “boolean” 如果这个值是布尔值; “string” 如果这个值是字符串 “number” 如果这个值是数值 “object” 如果这个值是对象或 null; “function” 如果这个值是函数null == undefined为true boolean 数据类型 转换为true的值 转换为false的值 Boolean true false String 任何非空字符串 “”(空字符串) Number 任何非零数字值(包括无穷大) 0和NaN Object 任何对象 null Undefined / undefined number浮点数值的最高精度是 17 位小数,a + b == 0.3为falseNaNNaN == NaN为false 数值转换 Number() 如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。 如果是数字值，只是简单的传入和返回。 如果是 null 值，返回 0。 如果是 undefined，返回 NaN。 如果是对象，则调用对象的 valueOf()方法，如果转换的结果是 NaN，则调用对象的 toString()方法 如果是字符串，遵循下列规则: 如果字符串中只包含数字,前导的零被忽略 如果字符串中包含有效的十六进制格式,则将其转换为相同大小的十进制整 数值; 如果字符串中包含有效的十六进制格式,则将其转换为相同大小的十进制整 数值; 如果字符串是空的(不包含任何字符)，则将其转换为 0 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。 parseInt() parseFloat() string转换为字符串 toString()var age = 11;var ageAsString = age.toString(); // 字符串\"11\" var found = true;var foundAsString = found.toString(); // 字符串\"true\" 数值、布尔值、对象和字符串值(没错，每个字符串也都有一个 toString()方法，该方法返回字 符串的一个副本)都有 toString()方法。但 null 和 undefined 值没有这个方法。在调用数值的 toString()方法时，可 以传递一个参数,toString()可以输出以二进制、八进制、十六进制， String() 如果值有 toString()方法，则调用该方法(没有参数)并返回相应的结果; 如果值是 null，则返回”null”; 如果值是 undefined，则返回”undefined”。 objectObject 的每个实例都具有下列属性和方法 constructor:保存着用于创建当前对象的函数。对于前面的例子而言，构造函数(constructor) 就是 Object()。 Prototype: 对该对象的对象原型的引用。对于所有的对象，它默认返回 Object 对象的一个实例 hasOwnProperty(propertyName):用于检查给定的属性在当前对象实例中(而不是在实例 的原型中)是否存在。其中，作为参数的属性名(propertyName)必须以字符串形式指定(例 如:o.hasOwnProperty(“name”))。 isPrototypeOf(object):用于检查传入的对象是否是传入对象的原型。 PropertyIsEnumerable(name): 判断给定的属性是否可以用 for…in 语句进行枚举。 toString() valueOf() instanceof操作符instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型 in操作符用来判断某个属性属于某个对象 函数arguments对象属性 length 返回函数形参实际长度 argument[index] 获取函数参数值 argument.callee 返回函数本身 Function属性和方法 length 返回函数定义的形参个数 引用类型Object属性 Configurable 表示能否通过 delete 删除属性从而重新定义属性 Object.defineProperty(obj,key,config) Enumerable 表示能否通过 for-in 循环返回属性。 Writable 表示能否修改属性的值 Value 包含这个属性的数据值 Get 在读取属性时调用的函数。默认值为 undefined Set 在写入属性时调用的函数。默认值为 undefined object.keys(obj) 原型 var book = &#123; _year: 2004,edition: 1 &#125;;Object.defineProperty(book, \"year\", &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004;&#125; &#125;&#125;);book.year = 2005; alert(book.edition); //2 Array常见方法属性： constructor length prototype Array.isArray(arr) 检测是否是数组 indexOf(item) 返回下标 lastIndexOf() every() 每一项为true 返回true some() 一项为true 返回true filter() 返回该函数会返回 true 的项组成的数组 map() 返回每次函数调用的结果组成的数组 forEach() 没有返回值 concat(arr1，arr2) 连接两个或多个数组 join(code) 将数组使用code拼接成字符串 pop() 删除并返回最后一个元素 push(item,…) 向数组末尾添加一个或多个新元素，返回数组长度 reverse() 将数组顺序颠倒 shift() 删除并返回数组第一个元素 unshift() 在数组最前面添加一个或多个元素，返回数组长度 sort() 对数组进行排序 slice() 切割返回的数组 splice(index,delete,item) index操作第几个，delete 删除个数，item为添加的元素 Date “月/日/年”，如 6/13/2004; “英文月名 日,年”，如 January 12,2004; “英文星期几 英文月名 日 年 时:分:秒 时区”，如 Tue May 25 2004 00:00:00 GMT-0700。 ISO 8601 扩展格式 YYYY-MM-DDTHH:mm:ss.sssZ(例如 2004-05-25T00:00:00)。只有兼容ECMAScript 5 的实现支持这种格式。 常见属性和方法： Date.now() toDateString()——以特定于实现的格式显示星期几、月、日和年; toTimeString()——以特定于实现的格式显示时、分、秒和时区; 10  toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年; toLocaleTimeString()——以特定于实现的格式显示时、分、秒; toUTCString()——以特定于实现的格式完整的 UTC 日期。 RegExp属性和方法 global:布尔值，表示是否设置了 g 标志。 ignoreCase:布尔值，表示是否设置了 i 标志。 lastIndex:整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。 multiline:布尔值，表示是否设置了 m 标志。 source:正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。 exec(string) 返回包含第一个匹配项信息的数组 test(string) 检查字符串是否与给出的正则表达式模式相匹配，如果是则返回 true，否则就返回 false。 在非全局匹配模式下，则不存在这个问题 在全局匹配模式下 对于同一个正则对象重复调用就会出现下一次的匹配位置从上一次匹配结束的位置开始,解决方法重置lastIndex为0let reg = /^[\\d]&#123;2&#125;$/g;let str = \"12\";console.log(reg.test(str)); //返回truelet = \"123\";console.log(reg.test(str)); //从数字3开始匹配，只有一个数字，故返回false// 重置lastIndex为0 let reg = /^[\\d]&#123;2&#125;$/g;let str = \"12\";console.log(reg.test(str)); //返回truelet = \"123\";reg.lastIndex = 0;console.log(reg.test(str)); //返回true String属性和方法： charAt() 返回在指定位置的字符。 concat() 连接字符串。 indexOf() 检索字符串。 lastIndexOf() 从后向前搜索字符串。 match() 找到一个或多个正则表达式的匹配。 replace() 替换与正则表达式匹配的子串。 serach() 检索与正则表达式相匹配的值。 slice() 提取字符串的片断，并在新的字符串中返回被提取的部分。 split() 把字符串分割为字符串数组。 substring() 提取字符串中两个指定的索引号之间的字符。 substr() 从起始索引号提取字符串中指定数目的字符。 toLowerCase() toUpperCase() localeCompare() 用本地特定的顺序来比较两个字符串。 Global encodeURI() 对URI编码 encodeURIComponent() 对URI编码 decodeURI() 解码 decodeURIComponent() 解码 eval() window Math Math.ceil() 向上取整 Math.floor() 向下取整 Math.round() 四舍五入 Math.random() 0~1Math.floor(Math.random() * (max - min + 1) + min) 原型与原型链 prototype proto constructor DOMNode节点: 构成HTML文档最基本的单元常用节点分为四类： 文档节点 整个HTML文档 元素节点 HTML文档中的HTML标签 属性节点 元素的属性 文本节点 HTML标签里的文本内容 NodeName NodeType NodeValue 文档节点 #document 9 null 元素节点 标签名 1 null 属性节点 属性名 2 属性值 文本节点 #text 3 文本内容 node属性和方法 nodeName nodetype nodevalue firstChild lastChild parentNode childNodes nextSibling previousSibling cloneNode() appendChild() insertBefore() replaceChild() element继承Node className innerHTML getAttribute() setAttribute() attributes -&gt; 返回nodeMap getAttributeNodes() hasAttribute() attri isid name value 事件事件冒泡 事件捕获 Dom事件流 DOM0btn.click() DOM2btn.addEventListener(event,function,boolean) true 捕获阶段 触发事件 false 冒泡阶段触发事件btn.removeEventListener(event,function,boolean) btn.attachEvent(event,function iebtn.detcahEvent()","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.zhengyuyan.com/tags/javascript/"}]},{"title":"mac-npm-exception.md","date":"2019-02-27T12:08:25.000Z","path":"201902/27/mac-npm-exception-md/","text":"mac系统npm安装包时，报Error: EACCES: permission denied, access ` 使用节点版本管理器重新安装npm（推荐） NPM_CONFIG_PREFIX=~/.npm-global 参考文档","tags":[{"name":"mac","slug":"mac","permalink":"https://www.zhengyuyan.com/tags/mac/"}]},{"title":"javaweb","date":"2019-02-11T11:18:58.000Z","path":"201902/11/javaweb/","text":"tomcat解压目录 bin:可执行文件(startup.bat shutdown.bat) conf:配置文件(server.xml) lib:Tomcat依赖的jar文件 log:日志文件(记录出错等信息) temp:临时文件 webapps:可执行的项目(开发的项目，放入该目录) work:存放由jsp翻译成的java，以及编译成的class文件 配置tomcat tomcat依赖java,必须配置JAVA_HOME 配置CATALINA_HOME(tomcat根目录) 每个项目都有WEB-INF文件夹 (WEB_INF里有classes文件夹、lib文件夹、web.xml) 配置虚拟路径 Host标签添加Context标签 &lt;Context docBase=&quot;&quot; path=“”&gt; (docBase实际路径 path 虚拟路径 ) 配置虚拟路径 也可在conf/Catalina/localhost 中新建”项目名.xml”中新增一行&lt;Context docBase=&quot;&quot; path=“”&gt; 虚拟主机 jsp执行流程第一次jsp -&gt; java -&gt; class(生成的java和class在work/Catalina/localhost(Host)/项目名/org/apcahe/jsp文件夹里)第二次直接访问class文件 jsp页面元素 脚本Scriptlet &lt;% 局部变量java语句 %&gt; &lt;%! 全局变量 %&gt; //输出表达式 &lt;%=%&gt; 注释 指令 page 网页开头指定页面属性 language import 导入类 pageEncoding:jsp 文件自身编码 contentType:浏览器解析jsp编码 include taglib jsp9大内置对象 out: 向客户端输出 pageContext: request：请求对象，存储客户端向服务端发送的请求信息 String request.getParameter(string name) 获取请求参数 String[] request.getParameterValues(string name) 获取数组参数 void request.setCharacterencoding(string code) 设置编码 request.getServerletContext() 获取serverletcontext对象 request.getRequestDispatcher(“yemian”).forward(request,response) 请求转发 request.getcookies() response： 相应对象 void response.addCookie(Cookie cookie) 服务端向客户端添加cookie void sendRedirect(String location) 重定向 页面跳转 重定向 数据丢失 void setContenType(String type) 设置服务端相应编码 session: 会话 开始-&gt;关闭 是一次会话，客户端第一次请求服务端时，服务端会产生一个session对象，用于保存信息，并且每个session对象，都会有一个唯一的sessionId(用于区分其他session)，服务端也会生成一个cookie,并且该cookie的name=JESSSIONID，value=服务端sessionId，然后 服务端会在 相应客户端的同事 将该cookie发送给客户端，至此，客户端就有了一个cookie(JSESSIONID),因此，客户端的cookie就可以和服务端的session一一对应 application: 全局对象 application.getContextpath() 获取虚拟路径 application.getRealPath() 绝对路径（虚拟路径对应的绝对路径） config page exception JDBCJDBC API:提供各种操作访问接口 Connection Statement PrepareStatament ResultSet DriverManager:连接 Connection:连接 Statement(PrepareStatament): 增删改查 CallableStatement:调用函数或存储过程 Result:返回结果 数据库驱动 Oracle ojdbc-x.jar oracle.jdbc.OracleDriver Mysql mysql-connector-java-x.jar com.mysql.jdbc.Driver SqlServer sqljdbc-x.jar com.microsoft.sqlserver.jdbc.SQLServerDriver // 导入驱动类Class.forName(\"驱动类\");// 与数据库建立连接Connectio connection = DriverManager.getConnectioin(url,user,password);// 执行sqlStatement stmt = connection.createStatement();int i = stmt.executeUpdate(\"sql\");//返回值标识 增 删改 几条数据ResultSet rst = stmt.executeQuery(\"sql\"); // 查询stmt.close();connection.close(); PrepareStatement操作sql:”select * from xxx where id=?”PrepareStatement.setString(1,”01”);赋值操作setXXX(int index,XXX); 占位符 PrepareStatement与Statement区别函数或存储过程参数格式： 存储过程 无返回值 有Out参数代替 {call 存储过程名（参数列表）} 存储函数 有返回值 {call 村塾函数名(参数列表)}// 导入驱动类 Class.forName(\"驱动类\"); // 与数据库建立连接 Connectio connection = DriverManager.getConnectioin(url,user,password); CallableStatement csmt = connection.prepareCall(\"&#123;call 存储过程名（参数列表）&#125;\"); csmt.execute() 处理CLOB[text]/BLOB类型 CLOB: 大文本数据 BLOB: 二进制 存放路径 Serverletserverlet2.5 extend Httpservelet @Overide doGet(HttpRequest request,HttpResponse response) @Overide doPost(HttpRequest request,HttpResponse response) 配置web.xml &lt;Serverlet&gt; &lt;serverlet-name&gt;a&lt;/serverlet-name&gt; &lt;server-class&gt;com.xx.xxx&lt;/serverlet-class&gt;&lt;/Serverlet&gt;&lt;Serverlet-mapping&gt; &lt;serverlet-name&gt;a&lt;/serverlet-name&gt; &lt;serverlet-url&gt;/xxx&lt;/serverlet-url&gt;&lt;/Serverlet-mapping&gt; serverlet3.0 extend Httpservelet @Overide doGet(HttpRequest request,HttpResponse response) @Overide doPost(HttpRequest request,HttpResponse response) 在类上添加注解@WebServerlet(value=”/xxxx”) serverlet生命周期 加载（容器自动处理） 初始化 init() 只运行一次 服务（doget,dopost） 销毁 destory() 关闭容器时运行，只运行一次 卸载 getinitParameter(String name) serverlet (super.getinitParameter(“xxxxx”)) 3.0 @WebServerlet(value=”xxx”,initParams={@WebInitParam()}) 2.5&lt;Serverlet&gt; &lt;serverlet-name&gt;a&lt;/serverlet-name&gt; &lt;server-class&gt;com.xx.xxx&lt;/serverlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;serverletparamname&lt;/param-name&gt; &lt;param-value&gt;value&lt;/param-value&gt; &lt;/init-param&gt;&lt;/Serverlet&gt;&lt;Serverlet-mapping&gt; &lt;serverlet-name&gt;a&lt;/serverlet-name&gt; &lt;serverlet-url&gt;/xxx&lt;/serverlet-url&gt;&lt;/Serverlet-mapping&gt; 容器的值 （super.getServerletContenttext().getinitParameter(name=”xxxx”,value=”xxxx”)） &lt;context-param&gt; &lt;param-name&gt;globalamname&lt;/param-name&gt; &lt;param-value&gt;globalvalue&lt;/param-value&gt;&lt;/context-param&gt; 文件上传 commons-fifleupload.jar commons-io.jar El表达式EL存取变量数据的方法很简单，例如：${username}。它的意思是取出某一范围中名称为username的变量。因为我们并没有指定哪一个范围的username，所以它会依序从Page、Request、Session、Application范围查找。 Page -&gt; PageScope Request -&gt; RequestScope Session -&gt; SessionScope Application -&gt; ApplicationScope jstl 引入两个jar包 jstl.jar,standard.jar 引入taglib &lt;%@ taglib uri=””,prefix=”c”%&gt; 通用标签库 &lt;c:set var=””, value=””, scope=””&gt; 给某个变量赋值(scope:request,session,application) 相当于request.setAttribute() &lt;c:out&gt; 条件标签库 &lt;c:if test=”” var=”result”&gt; result是结果 true false &lt;c:choose&gt;&lt;c:when test=””&gt;&lt;/c:when&gt;&lt;c:otherwise&gt;&lt;/c:otherwise&gt;&lt;/c:choose&gt; 迭代标签库 &lt;c:forEach begin=”” end=”” step=”” varStatus=”status”&gt;${status.index}&lt;/c:forEach&gt; &lt;c:forEach var=”students” items=”student”&gt;&lt;/c:forEach&gt; 过滤器 implements Filter(javax.serverlet.Filter) 重写init(),doFilter(),destory() system.out.print(\"请求拦截\");chain.dofilter(request,response)system.out.print(\"响应拦截\"); 配置web.xml&lt;filter&gt; &lt;filter-name&gt;xxxx&lt;/filter-name&gt; &lt;filter-class&gt;XXX&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;xxxx&lt;/filter-name&gt; &lt;url-pattern&gt;xxxx&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 监听器 implements ServerletRequestListener,HttpSessionLister,SeverletContextListener implements ServerletRequestAttributeListener, HttpSessionAttributeListener,SeverletContextAttributeListener 监听属性更改 重写(监听开始结束) 配置web.xml&lt;listener&gt; &lt;listener-class&gt;xxxxx&lt;/listener-class&gt;&lt;/listener&gt; 脑图","tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://www.zhengyuyan.com/tags/javaweb/"}]},{"title":"java修饰符","date":"2018-12-27T14:48:14.000Z","path":"201812/27/java修饰符/","text":"Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符： 访问控制修饰符 : default, public , protected, private 非访问控制修饰符 : final, abstract, static, synchronized 访问控制修饰符 default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 修饰符 当前类 同一包内 子孙包(同一包) 子孙包(不同包) 其他包 public Y Y Y Y Y protected Y Y Y Y N default Y Y Y N N private Y N N N N 受保护的访问修饰符-protectedprotected 需要从以下两个点来分析说明： 子类与基类在同一包中：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问； 子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。 访问控制和继承请注意以下方法继承的规则： 父类中声明为 public 的方法在子类中也必须为 public。 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。 父类中声明为 private 的方法，不能够被继承。 非访问修饰符为了实现一些其他的功能，Java 也提供了许多非访问修饰符。 static 修饰符，用来修饰类方法和类变量。 final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 abstract 修饰符，用来创建抽象类和抽象方法。 synchronized 和 volatile 修饰符，主要用于线程的编程。 static 修饰符静态变量：static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。静态方法：static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。 final 修饰符final 变量：final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。final 修饰符通常和 static 修饰符一起使用来创建类常量。final 方法类中的 final 方法可以被子类继承，但是不能被子类修改。声明 final 方法的主要目的是防止该方法的内容被修改。 synchronized 修饰符synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。 transient 修饰符序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。 volatile 修饰符volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。一个 volatile 对象引用可能是 null。","tags":[{"name":"java基础","slug":"java基础","permalink":"https://www.zhengyuyan.com/tags/java基础/"}]},{"title":"java","date":"2018-12-17T13:21:17.000Z","path":"201812/17/java/","text":"classpathjava中classpath配置的是class文件生成的地址，和运行java命令去找class文件的地址,一般不做配置 java数据类型基本类型：byte(1字节),short(2字节),int(4字节),long(8字节),float(4字节),double(8字节),char(2字节),boolean引用类型：class,接口,数组,枚举等 基本类型转换boolean不能转换为其他数据类型默认转换byte,short,char-&gt;int-&gt;long-&gt;float-&gt;doublebyte,short,chart之间不转换,他们参与运算首先转换为int在定义long或者float类型变量时，加L或者F(整数默认是int，浮点数默认是double)byte a = 3;byte b = 4;// a+b结果为int//byte c = a + b;byte c = (byte) (a+b);float f = 3.14F;long l = 10000000L; 方法重载在同一个类中，允许存在一个以上的同名方法，只要参数的个数或者参数类型不通即可。与返回值类型无关，只看方法名和参数列表 数组数组初始化：数组必须初始化，然后才能使用，为数组的元素分配内存空间，并为每个数组元素赋值 数组初始化方式 静态初始化：初始化只指定数组长度，由系统为数组分配初始值 int[] a = new int[3] 动态初始化：初始化时指定每个数组元素的初始值，由系统决定长度 int[] a = new int[]{1,2,3}数组常见错误 不要同时进行静态和动态赋值 数组越界 空指针异常 方法可变参数//定义typeName... parameterNamepublic class VarargsDemo &#123; public static void main(String args[]) &#123; // 调用可变参数的方法 printMax(34, 3, 3, 2, 56.5); printMax(new double[]&#123;1, 2, 3&#125;); &#125; public static void printMax( double... numbers) &#123; if (numbers.length == 0) &#123; System.out.println(\"No argument passed\"); return; &#125; double result = numbers[0]; for (int i = 1; i &lt; numbers.length; i++)&#123; if (numbers[i] &gt; result) &#123; result = numbers[i]; &#125; &#125; System.out.println(\"The max value is \" + result); &#125;&#125; java内存分配 栈 存放的是局部变量 堆 存放的是所有new出来的对象 方法区 (方法在栈里执行) 本地方法(系统相关) 寄存器(cpu)：不可控制 堆内存特点 每一个new出来的对象都有一个地址值 每个变量都有默认值 byte,short,int,long都为0 float,double 为0.0 char 为’\\u0000’ boolean 为false 引用类型为null 使用完毕就变成垃圾，但并没有立即回收，会在垃圾回收器空闲时回收，这就是java占内存的原因 int[] a = new int[3]; 栈内存特点 用完就释放 栈内存的两个引用指向同一个堆内存空间，无论操作哪个，都针对同一个地方 public class ArgDemo&#123; public static void main(String[] args)&#123; int a = 10; int b = 20; change(a,b); int[] arr = new int[]&#123;1,2,3,4,5&#125;; change(arr); &#125; public static void change(int a,int b)&#123; a = b; b = a + b; &#125; public static void main(int[] arr)&#123; for(int x = 0 ; x &lt; arr.length;x++)&#123; if(x%2==0)&#123; arr[x] = arr[x] * 2; &#125; &#125; &#125;&#125; java对象内存图 成员变量和局部变量 成员变量在类中 局部变量在方法中定义或方法参数 成员变量在堆内存中 局部变量在栈内存中 成员变量随着对象的创建而创建，随着对象的消失而消失 局部变量随着方法的调用而存在，随着方法调用完毕而消失 有默认初始化值 没有默认初始化值，必须定义赋值后使用 访问修饰符private 权限修饰符 可以修饰成员(成员变量和成员方法) 被private修饰的成员只能在本类中才能访问 static 可以修饰成员变量和成员方法 随着类的加载而加载 优先于对象存在 被类的所有对象共享 可以通过类名调用 静态方法中没有this关键字 静态方法只能访问静态成员变量和静态方法 静态变量和成员变量 静态变量属于类，所以也称类变量 成员变量属于对象，所以称为实例变量(对象变量) 静态变量存储于方法的静态区 成员变量存储于堆内存 成员变量随着对象的创建而创建，随着对象的消失而消失 静态变量随着类的加载而加载，随着类的消失而消失 静态变量可以通过对象调用，也可以通过类名调用 成员变量只能通过对象名调用 继承 低耦合 ：类与类之间的关系 高内聚 ：独立完成一件事情的能力 单继承 子类只能继承父类所有非私有的成员(成员方法和成员变量) 子类不能继承父类的构造方法，但是可以通过super关键字去访问父类构造方法 在子类方法的局部范围找，有就使用 在子类的成员范围找，有就使用 在父类的成员范围找，有就使用 如果找不到，报错 多态 某一个事物，在不同时刻表现出不同状态 多态 继承 重写 父类引用指向子类引用 成员变量 编译看左边，运行看左边 构造方法 创建子类对象时，访问父类构造方法，对父类的数据进行初始化 成员方法 编译看左边，运行看右边 静态方法 编译看左边，运行看左边 向上转型 Fu f = new Zi(); 向下转型 Zi z = (Zi) f; 正则表达式 字符 a 字符a \\ 反斜杠 \\n 换行 \\r 回车 字符类 [abc] a,b或c [^abc] 任何字符 除了a,b,c [a-zA-Z] a-z或A-Z [0-9] 0到9 预定义字符类 . 任意字符 \\d 数字:[0-9] \\w [a-zA-Z_0-9] 单词字符 边界匹配器 ^ 行的开始 $ 行的结尾 \\b 单词边界 不是单词字符的地方 数量词 x? x,一次或一次也没有 x* x,零次或多次 x+ x,一次或多次 x{n} x,恰好n次 x{n,} x,至少n次 x{n,m} x,至少n次但不超过m次Pattern和Matcher要先find() 然后group(捕获),不然报错IllgalstaeException 获取任意范围随机数(int) (Math.random() * (end - start + 1)) + start System静态类 成员方法 public static void gc() 垃圾回收器 调用finalize(); 不要频繁调用 public static void exit(int status) 终止当前运行的java虚拟机，非0表示异常终止 public static long currentTimeMillis() public static arrarycopy() 常见数据结构 栈 先进后出 压栈 弹栈 队列 先进先出 数组 链表 数据和地址 树 哈希表 List的子类特点 ArrayList 底层数据结构是数组，查询快，增删慢，线程不安全，效率高 Vector 底层数据结构是数组，查询快，增删慢，线程安全，效率低 LinkedList 底层数据结构是链表，查询慢，增删快，线程不安全，效率高 泛型 泛型类 public class 类名&lt;泛型类型1…&gt; 泛型类型必须是引用类型 泛型方法 泛型通配符 泛型通配符&lt;?&gt; 任意类型 ? extends E 向下限定，E及其子类 ? super E 向上限定，E及其父类 静态导入import static 包名….类名.方法名方法必须是静态的如果有多个同名的静态方法，必须加前缀 IO异常程序异常: Throwable严重问题: Error问题: Exception (编译问题，运行问题(RuntimeException)) 一旦try里面出现了问题，就会抛出异常，然后和catch里的异常进行匹配，一旦匹配到了，就执行catch语句，然后结束了try…catch继续执行后面的语句 throws使用定义方法时，需要把出现的问题暴露出来，让调用者去处理，那么通过throws在方法上标识，方法抛出的是编译时异常必须要处理，如果抛出的是运行时异常可以不用处理 throw在功能方法内部出现某种情况，程序不能继续运行，需要进行跳转，用异常把对象抛出 finallyfinally语句块一定会被执行，catch里有return语句 会先执行finally语句块，然后执行return语句，用于释放资源 自定义异常 继承Exception 继承RuntimeException 流流向输入流(读)，输出流(写) 数据类型字节流,字符流(操作文本) InputStream 字节输入流 OutputStream 字节输出流 Reader 字符输入流 Writer 字符输出流 序列化流 ObjectOutputStream 序列化 将对象按照流一样的方式存入文本文件或者网络中传输 ObjectInputStream 反序列化 将文本文件中的流对象或者网络中的流对象数据还原成对象//序列化ObjectOutputStream obs = new ObjectInputStream(new FileOutputStream(\"d:\\\\a.txt\"));Person p = new Person();obs.writeObject(p);obs.close();//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"d:\\\\a.txt\"));Object o = ois.readObject();ois.close(); 要实现序列化的对象须实现Serialible接口，如果不想某个属性被序列化加上transientpublic static final long serialVersionUID = “-283289349237498723”; //随机生成 Propertiesjsonloadstore 多线程如果程序只有一条执行路径是单线程，如果有多条执行路径则是多线程 什么是进程通过任务管理器，可以看到进程的存在；只有运行的程序才有进程；就是正在运行的程序，是系统进资源分配和调用的独立单位每一个进程都有他自己的内存空间和系统资源 什么是线程在同一个进程内可以执行多个任务，每个任务可以看成一个线程线程是程序的执行单元 单线程：如果程序只有一条执行路径是单线程 多线程：如果有多条执行路径则是多线程 Java运行原理java命令启动java虚拟机，启动jvm，等于启动了一个应用程序，该进程会自动启动一个“主线程“，然后“主线程“去调用某个类的main方法，所以main方法运行在主线程中 实现多线程 extends Thread class Mythread extends Thread&#123; @Override public void run()&#123; // some code &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; // Mythread m1 = new Mythread(); Mythread m2 = new Mythread(); m1.start(); m2.start(); //不能同一个线程对象调用两次start &#125;&#125; 实现Runnable 线程调度 分时调度 所有线程轮流使用CP的使用权，平均分配给每个线程占用CPU的时间片 抢占式调度 优先让优先级高的线程使用CPU 线程默认优先级是5，优先级值为0-10 线程控制 线程休眠 sleep(long millis) 线程加入 join() 为了某些线程执行完毕 线程礼让 yield() 后台线程 setDaemon(boolean on) 中断线程 stop() interrupt() 线程生命周期 新建 创建线程对象 就绪 有执行资格，没有执行权 运行 有执行资格，有执行权 阻塞 由于一些操作，让线程处于该状态 没有执行资格，没有执行权，而另一些操作可以激活，激活后处于就绪状态 死亡 线程对象变成垃圾，等待被回收 线程安全问题 多线程 有共享数据 多条语句操作共享数据 解决线程完全问题实现 同步代码块 synchronized 或者Locksynchronized(对象)&#123; 需要同步的代码块&#125; 同步的特点 多个线程 多个线程使用同一个锁对象 死锁两个或两个以上的的线程在执行过程中因争夺资源产生的一种互相等待的情况同步嵌套容易产生死锁问题 等待唤醒 wait() 释放锁，notify() 在wait()处唤醒 notify() 线程转换图 线程组线程池设计模式面向对象设计原则 单一职责 高内聚，低耦合 开闭原则 对扩展开放，对修改关闭 里氏替换原则 在任何父类出现过的地方都可以用子类代替 依赖注入原则 依赖于抽象，不要依赖于具体实现 接口分离原则 迪米特原则 一个对象对其他对象尽可能的少了解 设计模式分类 创建型模式 简单工厂模式 工厂方法模式 抽象工厂模式 建造者模式 原型模式 单例模式 结构型模式 外观模式 适配模式 代理模式 装饰模式 桥接模式 组合模式 享元模式 行为型模式 模板方法模式 观察者模式 状态模式 职责链模式 命令模式 访问者模式 策略模式 备忘录模式 迭代器模式 解释器模式单例模式//饿汉public class Student&#123; private Student()&#123;&#125; private static Student s = new Student(); public static Student()&#123; return s; &#125;&#125;//懒汉,会产生线程安全问题，所以同步代码块publiic class Teacher&#123; private Teacher()&#123;&#125; private Teacher t = null; public synchronized static Teacher getTeacher()&#123; if(t == null)&#123; t = new Teacher(); &#125; return t; &#125;&#125; GUI网络编程网络三要素 IP地址 端口 协议IP地址分类 A类 1.0.0.1~127.255.255.254 第一号段为网络号段 + 后三段的主机号段 一个网络号： 256256256 B类 128.0.0.1~191.255.255.255 前二号段为网络号段 + 后二段的主机号段 一个网络号： 256*256 C类 192.0.0.1~223.255.255。254 前三号段为网络号段 + 后一段的主机号段 一个网络号： 256 D类 224.0.0.1~39.55.255.254 E类 240.0.0.1~247.255.255.254 特殊的IP地址 127.0.0.1 回环地址 x.x.x.255 广播地址 x.x.x.0 网络地址 端口正在运行程序的标识有效端口: 0~65535 其中0-1024系统进程端口 协议 UDP 将数据源和目的封装成数据包，不需要建立连接，每个数据包的大小限制在64k；因无连接，不可靠协议，不需要建立连接，速度快 TCP 建立连接，形成传输数据的通道；在连接中进行大量数据传输，通过3次握手完成连接，是可靠协议；必须建立连接，效率低 SocketSocket套接字：网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的符套接字 类加载器和反射类的加载当程序要使用某个类时如果该类还未加载到内存中，则系统会通过加载，连续，初始化三步来实现对这个类的初始化 加载 就是将class文件读入内存中，并为之创建一个Class对象 任何类被使用时系统都会创建一个class对象 连续 验证 是否有正确的内部结构，并和其他类协调一致 准备 负责为类的静态成员分配内存，并设置默认初始化值 解析 将类的二进制数据中的符号引用替换为直接引用 初始化 类加载器的组成 BootStrap ClassLoader 跟类加载器 负责java核心类的加载 比如System,String等 jre/rt.jar Extension ClassLoader 扩展类加载器 负责JRE的扩展目录中的jar包加载 JRE目录下lib目录下的ext目录 System ClassLoader 系统类加载器 负责JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路劲 反射java反射是在运行状态对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态的获取的信息以及调用对象的方法的功能称为反射机制。 class类： 成员变量 Field 构造方法 Constructor 成员方法 Method","tags":[{"name":"java基础","slug":"java基础","permalink":"https://www.zhengyuyan.com/tags/java基础/"}]},{"title":"hexohelp","date":"2018-12-17T13:16:34.000Z","path":"201812/17/hexohelp/","text":"hexo常用命令init$ hexo init [folder] 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 new$ hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 generate$ hexo generate 生成静态文件。 选项 描述 -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 该命令可以简写为$ hexo g publish$ hexo publish [layout] &lt;filename&gt; 发表草稿。 server$ hexo server 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 选项 描述 -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 deploy$ hexo deploy 部署网站。 参数 描述 -g, --generate 部署之前预先生成静态文件 该命令可以简写为：$ hexo d render$ hexo render &lt;file1&gt; [file2] ... 渲染文件。 参数 描述 -o, --output 设置输出路径 migrate$ hexo migrate &lt;type&gt; 从其他博客系统 迁移内容。 clean$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 list$ hexo list &lt;type&gt; 列出网站资料。 version$ hexo version 显示 Hexo 版本。 选项安全模式$ hexo --safe 在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 调试模式$ hexo --debug 在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。 简洁模式$ hexo --silent 隐藏终端信息。 自定义配置文件的路径$ hexo --config custom.yml 自定义配置文件的路径，执行后将不再使用 _config.yml。 显示草稿$ hexo --draft 显示 source/_drafts 文件夹中的草稿文章。 自定义 CWD$ hexo --cwd /path/to/cwd 自定义当前工作目录（Current working directory）的路径。 参考文档hexo常用指令","tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.zhengyuyan.com/tags/hexo/"}]},{"title":"mac-Trouble","date":"2018-11-13T15:41:50.000Z","path":"201811/13/mac-homebrew/","text":"Mac安装homebrew失败 执行命令ruby -version,查看ruby版本 执行命令ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;后报错，报错信息如下 Cloning into &apos;/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core&apos;...fatal: unable to access &apos;https://github.com/Homebrew/homebrew-core/&apos;: LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54Error: Failure while executing; `git clone https://github.com/Homebrew/homebrew-core /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core --depth=1` exited with 128.Error: Failure while executing; `/usr/local/bin/brew tap homebrew/core` exited with 1. 解决,执行一下命令 git clone git://mirrors.ustc.edu.cn/homebrew-core.git/ /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core --depth=1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 等待安装即可 Mac安装mysql之后用navicat链接报错报错信息为：Authentication plugin &apos;caching_sha2_password&apos; cannot be loaded: dlopen(/usr/local/mysql/lib/plugin/caching_sha2_password.so, 2): image not found 解决 打开系统偏好设置，找到mysql，点击Initialize Database。 输入你的新密码。 选择‘Use legacy password‘。 重启mysql服务。 可以使用Navicat链接。 参考文档macOS安装homebrew报错 LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54Mysql 8.0.11版本，安装成功，使用Navicat连接失败","tags":[{"name":"mac","slug":"mac","permalink":"https://www.zhengyuyan.com/tags/mac/"}]},{"title":"gradle-repositry","date":"2018-11-13T15:36:29.000Z","path":"201811/13/gradle-repositry/","text":"idea使用gradle下载依赖包时，速度过慢,仓库地址可以使用如下地址buildscript &#123; repositories &#123; maven &#123; url &apos;https://maven.aliyun.com/repository/central&apos; &#125; maven&#123; url &apos;https://maven.aliyun.com/repository/jcenter&apos;&#125; maven&#123;//配置Maven仓库的地址 url &quot;http://repo.springsource.org/libs-milestone-local&quot; &#125; &#125;&#125;` 参考文档gradle公共仓库解决下载jar包太慢","tags":[{"name":"idea","slug":"idea","permalink":"https://www.zhengyuyan.com/tags/idea/"},{"name":"gradle","slug":"gradle","permalink":"https://www.zhengyuyan.com/tags/gradle/"}]},{"title":"Hello World","date":"2018-11-13T15:16:12.123Z","path":"201811/13/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","tags":[]},{"title":"istio metrics(六)","date":"2018-07-17T13:54:48.000Z","path":"201807/17/istio-metrics/","text":"Istio MetricsService Telemetry# Configuration for metric instancesapiVersion: \"config.istio.io/v1alpha2\"kind: metricmetadata: name: doublerequestcount namespace: istio-systemspec: value: \"2\" # count each request twice dimensions: source: source.service | \"unknown\" destination: destination.service | \"unknown\" message: '\"twice the fun!\"' monitored_resource_type: '\"UNSPECIFIED\"'---# Configuration for a Prometheus handlerapiVersion: \"config.istio.io/v1alpha2\"kind: prometheusmetadata: name: doublehandler namespace: istio-systemspec: metrics: - name: double_request_count # Prometheus metric name instance_name: doublerequestcount.metric.istio-system # Mixer instance name (fully-qualified) kind: COUNTER label_names: - source - destination - message---# Rule to send metric instances to a Prometheus handlerapiVersion: \"config.istio.io/v1alpha2\"kind: rulemetadata: name: doubleprom namespace: istio-systemspec: actions: - handler: doublehandler.prometheus instances: - doublerequestcount.metric---# Configuration for logentry instancesapiVersion: \"config.istio.io/v1alpha2\"kind: logentrymetadata: name: newlog namespace: istio-systemspec: severity: '\"warning\"' timestamp: request.time variables: source: source.labels[\"app\"] | source.service | \"unknown\" user: source.user | \"unknown\" destination: destination.labels[\"app\"] | destination.service | \"unknown\" responseCode: response.code | 0 responseSize: response.size | 0 latency: response.duration | \"0ms\" monitored_resource_type: '\"UNSPECIFIED\"'---# Configuration for a stdio handlerapiVersion: \"config.istio.io/v1alpha2\"kind: stdiometadata: name: newhandler namespace: istio-systemspec: severity_levels: warning: 1 # Params.Level.WARNING outputAsJson: true---# Rule to send logentry instances to a stdio handlerapiVersion: \"config.istio.io/v1alpha2\"kind: rulemetadata: name: newlogstdio namespace: istio-systemspec: match: \"true\" # match for all requests actions: - handler: newhandler.stdio instances: - newlog.logentry--- TCP Telemetry# Configuration for a metric measuring bytes sent from a server# to a clientapiVersion: \"config.istio.io/v1alpha2\"kind: metricmetadata: name: mongosentbytes namespace: defaultspec: value: connection.sent.bytes | 0 # uses a TCP-specific attribute dimensions: source_service: source.service | \"unknown\" source_version: source.labels[\"version\"] | \"unknown\" destination_version: destination.labels[\"version\"] | \"unknown\" monitoredResourceType: '\"UNSPECIFIED\"'---# Configuration for a metric measuring bytes sent from a client# to a serverapiVersion: \"config.istio.io/v1alpha2\"kind: metricmetadata: name: mongoreceivedbytes namespace: defaultspec: value: connection.received.bytes | 0 # uses a TCP-specific attribute dimensions: source_service: source.service | \"unknown\" source_version: source.labels[\"version\"] | \"unknown\" destination_version: destination.labels[\"version\"] | \"unknown\" monitoredResourceType: '\"UNSPECIFIED\"'---# Configuration for a Prometheus handlerapiVersion: \"config.istio.io/v1alpha2\"kind: prometheusmetadata: name: mongohandler namespace: defaultspec: metrics: - name: mongo_sent_bytes # Prometheus metric name instance_name: mongosentbytes.metric.default # Mixer instance name (fully-qualified) kind: COUNTER label_names: - source_service - source_version - destination_version - name: mongo_received_bytes # Prometheus metric name instance_name: mongoreceivedbytes.metric.default # Mixer instance name (fully-qualified) kind: COUNTER label_names: - source_service - source_version - destination_version---# Rule to send metric instances to a Prometheus handlerapiVersion: \"config.istio.io/v1alpha2\"kind: rulemetadata: name: mongoprom namespace: defaultspec: match: context.protocol == \"tcp\" &amp;&amp; destination.service == \"mongodb.default.svc.cluster.local\" actions: - handler: mongohandler.prometheus instances: - mongoreceivedbytes.metric - mongosentbytes.metric 参考文档istio metrics","tags":[{"name":"service Mesh","slug":"service-Mesh","permalink":"https://www.zhengyuyan.com/tags/service-Mesh/"},{"name":"istio","slug":"istio","permalink":"https://www.zhengyuyan.com/tags/istio/"}]},{"title":"istio策略管理(五)","date":"2018-07-17T13:51:44.000Z","path":"201807/17/istio-policy/","text":"Istio 策略管理Mixer 为应用程序和基础架构后端之间提供了一个通用的策略控制层，负责先决条件检查（如认证授权）、配额管理并从 Envoy 代理中收集遥测数据等。 Mixer 支持灵活的插件模型（即 Adapters），支持 GCP、AWS、Prometheus、Heapster 等各种丰富功能的后端。 实现原理本质上，Mixer 是一个 属性 处理机，进入 Mixer 的请求带有一系列的属性，Mixer 按照不同的处理阶段处理： 通过全局 Adapters 为请求引入新的属性 通过解析（Resolution）识别要用于处理请求的配置资源 处理属性，生成 Adapter 参数 分发请求到各个 Adapters 后端处理 Adapters 后端以 Mixer 配置 的方式注册到 Istio 中，参考这里查看示例配置 流量限制示例apiVersion: \"config.istio.io/v1alpha2\"kind: memquotametadata: name: handler namespace: istio-systemspec: quotas: - name: requestcount.quota.istio-system maxAmount: 5000 validDuration: 1s # The first matching override is applied. # A requestcount instance is checked against override dimensions. overrides: # The following override applies to 'ratings' when # the source is 'reviews'. - dimensions: destination: ratings source: reviews maxAmount: 1 validDuration: 1s # The following override applies to 'ratings' regardless # of the source. - dimensions: destination: ratings maxAmount: 100 validDuration: 1s---apiVersion: \"config.istio.io/v1alpha2\"kind: quotametadata: name: requestcount namespace: istio-systemspec: dimensions: source: source.labels[\"app\"] | source.service | \"unknown\" sourceVersion: source.labels[\"version\"] | \"unknown\" destination: destination.labels[\"app\"] | destination.service | \"unknown\" destinationVersion: destination.labels[\"version\"] | \"unknown\"---apiVersion: \"config.istio.io/v1alpha2\"kind: rulemetadata: name: quota namespace: istio-systemspec: actions: - handler: handler.memquota instances: - requestcount.quota---apiVersion: config.istio.io/v1alpha2kind: QuotaSpecmetadata: creationTimestamp: null name: request-count namespace: istio-systemspec: rules: - quotas: - charge: 1 quota: RequestCount---apiVersion: config.istio.io/v1alpha2kind: QuotaSpecBindingmetadata: creationTimestamp: null name: request-count namespace: istio-systemspec: quotaSpecs: - name: request-count namespace: istio-system services: - name: ratings - name: reviews - name: details - name: productpage 参考文档istio策略管理","tags":[{"name":"service Mesh","slug":"service-Mesh","permalink":"https://www.zhengyuyan.com/tags/service-Mesh/"},{"name":"istio","slug":"istio","permalink":"https://www.zhengyuyan.com/tags/istio/"}]},{"title":"istio安全管理(四)","date":"2018-07-17T13:48:36.000Z","path":"201807/17/istio-aq/","text":"Istio 安全管理Istio 提供了 RBAC 访问控制以及双向 TLS 认证等安全管理功能。 RBACIstio Role-Based Access Control (RBAC) 提供了 namespace、service 以及 method 级别的访问控制。其特性包括 简单易用：提供基于角色的语意 支持认证：提供服务 - 服务和用户 - 服务的认证 灵活：提供角色和角色绑定的自定义属性 开启RBAC# Enable RBAC for default namespaceistioctl create -f samples/bookinfo/kube/istio-rbac-enable.yaml 实现原理在实现原理上，Istio RBAC 作为 Mixer Adaper 对请求上下文（Request Context）进行认证，并返回授权结果：ALLOW 或者 DENY。请求上下文包含访问对象和动作等两部分，如apiVersion: \"config.istio.io/v1alpha2\"kind: authorizationmetadata: name: requestcontext namespace: istio-systemspec: subject: user: source.user | \"\" groups: \"\" properties: app: source.labels[\"app\"] | \"\" version: source.labels[\"version\"] | \"\" namespace: source.namespace | \"\" action: namespace: destination.namespace | \"\" service: destination.service | \"\" method: request.method | \"\" path: request.path | \"\" properties: app: destination.labels[\"app\"] | \"\" version: destination.labels[\"version\"] | \"\"---apiVersion: \"config.istio.io/v1alpha2\"kind: rbacmetadata: name: handler namespace: istio-systemspec: config_store_url: \"k8s://\"---apiVersion: \"config.istio.io/v1alpha2\"kind: rulemetadata: name: rbaccheck namespace: istio-systemspec: match: destination.namespace == \"default\" actions: - handler: handler.rbac instances: - requestcontext.authorization 访问控制Istio RBAC 提供了 ServiceRole 和 ServiceRoleBinding 两种资源对象，并以 CustomResourceDefinition (CRD) 的方式管理。 ServiceRole 定义了一个可访问特定资源（namespace 之内）的服务角色，并支持以前缀通配符和后缀通配符的形式匹配一组服务 ServiceRoleBinding 定义了赋予指定角色的绑定，即可以指定的角色和动作访问服务apiVersion: \"config.istio.io/v1alpha2\"kind: ServiceRolemetadata: name: service-viewer namespace: defaultspec: rules: - services: [\"*\"] methods: [\"GET\"] constraints: - key: \"app\" values: [\"productpage\", \"details\", \"reviews\", \"ratings\"]---apiVersion: \"config.istio.io/v1alpha2\"kind: ServiceRoleBindingmetadata: name: bind-service-viewer namespace: defaultspec: subjects: - properties: namespace: \"default\" - properties: namespace: \"istio-system\" roleRef: kind: ServiceRole name: \"service-viewer\" 双向 TLS双向 TLS 为服务间通信提供了 TLS 认证，并提供管理系统自动管理密钥和证书的生成、分发、替换以及撤销。 实现原理Istio Auth 由三部分组成： 身份（Identity）：Istio 使用 Kubernetes service account 来识别服务的身份，格式为 spiffe://&lt;domain&gt;/ns/&lt;namespace&gt;/sa/&lt;serviceaccount&gt; 通信安全：端到端 TLS 通信通过服务器端和客户端的 Envoy 容器完成 证书管理：Istio CA (Certificate Authority) 负责为每个 service account 生成 SPIFEE 密钥和证书、分发到 Pod（通过 Secret Volume Mount 的形式）、定期轮转（Rotate）以及必要时撤销。对于 Kuberentes 之外的服务，CA 配合 Istio node agent 共同完成整个过程。 这样，一个容器使用证书的流程为 首先，Istio CA 监听 Kubernetes API，并为 service account 生成 SPIFFE 密钥及证书，再以 secret 形式存储到 Kubernetes 中 然后，Pod 创建时，Kubernetes API Server 将 secret 挂载到容器中 最后，Pilot 生成一个访问控制的配置，定义哪些 service account 可以访问服务，并分发给 Envoy 而当容器间通信时，Pod 双方的 Envoy 就会基于访问控制配置来作认证 最佳实践 为不同团队创建不同 namespace 分别管理 将 Istio CA 运行在单独的 namespace 中，并且仅授予管理员权限 参考文档istio安全管理","tags":[{"name":"service Mesh","slug":"service-Mesh","permalink":"https://www.zhengyuyan.com/tags/service-Mesh/"}]},{"title":"istio流量管理(三)","date":"2018-07-17T13:43:40.000Z","path":"201807/17/istio-traffic/","text":"Istio 流量管理Istio 提供了强大的流量管理功能，如智能路由、服务发现与负载均衡、故障恢复、故障注入等。 流量管理的功能由 Pilot 配合 Envoy 负责，并接管进入和离开容器的所有流量： API 版本Istio 0.7.X 及以前版本仅支持 config.istio.io/v1alpha2，0.8.0 将其升级为 networking.istio.io/v1alpha3，并且重命名了流量管理的几个资源对象： RouteRule -&gt; VirtualService DestinationPolicy -&gt; DestinationRule EgressRule -&gt; ExternalService Ingress -&gt; Gateway 服务发现和负载均衡为了接管流量，Istio 假设所有容器在启动时自动将自己注册到 Istio 中（通过自动或手动给 Pod 注入 Envoy sidecar 容器）。Envoy 收到外部请求后，会对请求作负载均衡，并支持轮询、随机和加权最少请求等负载均衡算法。除此之外，Envoy 还会以熔断机制定期检查服务后端容器的健康状态，自动移除不健康的容器和加回恢复正常的容器。容器内也可以返回 HTTP 503 显示将自己从负载均衡中移除。 流量接管原理Envoy sidecar 使用 iptables 把进入 Pod 和从 Pod 发出的流量转发到 Envoy 进程监听的端口（即 15001 端口）上：# Generated by iptables-save v1.6.0 on Fri Jun 8 07:37:33 2018*mangle:PREROUTING ACCEPT [2883:1129969]:INPUT ACCEPT [2883:1129969]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [58217:6662600]:POSTROUTING ACCEPT [58217:6662600]COMMIT# Completed on Fri Jun 8 07:37:33 2018# Generated by iptables-save v1.6.0 on Fri Jun 8 07:37:33 2018*nat:PREROUTING ACCEPT [0:0]:INPUT ACCEPT [0:0]:OUTPUT ACCEPT [299:27815]:POSTROUTING ACCEPT [299:27815]:ISTIO_INBOUND - [0:0]:ISTIO_OUTPUT - [0:0]:ISTIO_REDIRECT - [0:0]-A PREROUTING -p tcp -j ISTIO_INBOUND-A OUTPUT -p tcp -j ISTIO_OUTPUT-A ISTIO_INBOUND -p tcp -m tcp --dport 9080 -j ISTIO_REDIRECT-A ISTIO_OUTPUT ! -d 127.0.0.1/32 -o lo -j ISTIO_REDIRECT-A ISTIO_OUTPUT -m owner --uid-owner 1337 -j RETURN-A ISTIO_OUTPUT -m owner --gid-owner 1337 -j RETURN-A ISTIO_OUTPUT -d 127.0.0.1/32 -j RETURN-A ISTIO_OUTPUT -j ISTIO_REDIRECT-A ISTIO_REDIRECT -p tcp -j REDIRECT --to-ports 15001COMMIT# Completed on Fri Jun 8 07:37:33 2018 故障恢复Istio 提供了一系列开箱即用的故障恢复功能，如 超时处理 重试处理，如限制最大重试时间以及可变重试间隔 健康检查，如自动移除不健康的容器 请求限制，如并发请求数和并发连接数 熔断 这些功能均可以使用 VirtualService 动态配置。比如以下为用户 jason 的请求返回 500 （而其他用户均可正常访问）：apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata: name: ratingsspec: hosts: - ratings http: - match: - headers: cookie: regex: \"^(.*?;)?(user=jason)(;.*)?$\" fault: abort: percent: 100 httpStatus: 500 route: - destination: host: ratings subset: v1 - route: - destination: host: ratings subset: v1 熔断示例：apiVersion: networking.istio.io/v1alpha3kind: DestinationRulemetadata: name: httpbinspec: host: httpbin trafficPolicy: connectionPool: tcp: maxConnections: 1 http: http1MaxPendingRequests: 1 maxRequestsPerConnection: 1 outlierDetection: http: consecutiveErrors: 1 interval: 1s baseEjectionTime: 3m maxEjectionPercent: 100 故障注入Istio 支持为应用注入故障，以模拟实际生产中碰到的各种问题，包括 注入延迟（模拟网络延迟和服务过载） 注入失败（模拟应用失效）这些故障均可以使用 VirtualService 动态配置。如以下配置 2 秒的延迟：apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata: name: ratingsspec: hosts: - ratings http: - fault: delay: percent: 100 fixedDelay: 2s route: - destination: host: ratings subset: v1 金丝雀部署 首先部署 bookinfo，并配置默认路由为 v1 版本：apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata: name: productpagespec: hosts: - productpage gateways: - bookinfo http: - route: - destination: host: productpage subset: v1---apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata: name: reviewsspec: hosts: - reviews http: - route: - destination: host: reviews subset: v1---apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata: name: ratingsspec: hosts: - ratings http: - route: - destination: host: ratings subset: v1---apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata: name: detailsspec: hosts: - details http: - route: - destination: host: details subset: v1---apiVersion: networking.istio.io/v1alpha3kind: DestinationRulemetadata: name: productpagespec: host: productpage subsets: - name: v1 labels: version: v1------apiVersion: networking.istio.io/v1alpha3kind: DestinationRulemetadata: name: reviewsspec: host: reviews subsets: - name: v1 labels: version: v1 - name: v2 labels: version: v2 - name: v3 labels: version: v3---apiVersion: networking.istio.io/v1alpha3kind: DestinationRulemetadata: name: ratingsspec: host: ratings subsets: - name: v1 labels: version: v1 - name: v2 labels: version: v2 - name: v2-mysql labels: version: v2-mysql - name: v2-mysql-vm labels: version: v2-mysql-vm---apiVersion: networking.istio.io/v1alpha3kind: DestinationRulemetadata: name: detailsspec: host: details subsets: - name: v1 labels: version: v1 - name: v2 labels: version: v2--- 示例一：将 10% 请求发送到 v2 版本而其余 90% 发送到 v1 版本apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata: name: reviewsspec: hosts: - reviews http: - route: - destination: host: reviews subset: v1 weight: 90 - destination: host: reviews subset: v2 weight: 10 示例二：将 jason 用户的请求全部发到 v2 版本apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata: name: reviewsspec: hosts: - reviews http: - match: - headers: cookie: regex: \"^(.*?;)?(user=jason)(;.*)?$\" route: - destination: host: reviews subset: v2 - route: - destination: host: reviews subset: v1 示例三：全部切换到 v2 版本apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata: name: reviewsspec: hosts: - reviews http: - route: - destination: host: reviews subset: v2 示例四：限制并发访问apiVersion: networking.istio.io/v1alpha3kind: DestinationRulemetadata: name: reviewsspec: host: reviews subsets: - name: v1 labels: version: v1 trafficPolicy: connectionPool: tcp: maxConnections: 100 Istio IngressIstio 在部署时会自动创建一个 Istio Gateway，用来控制 Ingress 访问。# prepare自动注入kubectl apply -f samples/httpbin/httpbin.yaml# get ingress external IP (suppose load balancer service)kubectl get svc istio-ingressgateway -n istio-systemexport INGRESS_HOST=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='&#123;.status.loadBalancer.ingress[0].ip&#125;')export INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='&#123;.spec.ports[?(@.name==\"http\")].port&#125;')export SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='&#123;.spec.ports[?(@.name==\"https\")].port&#125;')# create gatewaycat &lt;&lt;EOF | istioctl create -f -apiVersion: networking.istio.io/v1alpha3kind: Gatewaymetadata: name: httpbin-gatewayspec: selector: istio: ingressgateway # use Istio default gateway implementation servers: - port: number: 80 name: http protocol: HTTP hosts: - \"httpbin.example.com\"EOF# configure routes for the gatewaycat &lt;&lt;EOF | istioctl create -f -apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata: name: httpbinspec: hosts: - \"httpbin.example.com\" gateways: - httpbin-gateway http: - match: - uri: prefix: /status - uri: prefix: /delay route: - destination: port: number: 8000 host: httpbinEOF# validate 200curl --resolve httpbin.example.com:$INGRESS_PORT:$INGRESS_HOST -HHost:httpbin.example.com -I http://httpbin.example.com:$INGRESS_PORT/status/200# invalidate 404curl --resolve httpbin.example.com:$INGRESS_PORT:$INGRESS_HOST -HHost:httpbin.example.com -I http://httpbin.example.com:$INGRESS_PORT/headers 使用 TLS：# 生成证书git clone https://github.com/nicholasjackson/mtls-go-examplecd mtls-go-example#该命令将产生四个目录：1_root，2_intermediate，3_application和4_client与你将使用客户端和服务器证书。generate.sh bookinfo.example.com &lt;password&gt;# istio-ingressgateway-certs必须在istio-system命名空间中kubectl create -n istio-system secret tls istio-ingressgateway-certs --key 3_application/private/httpbin.example.com.key.pem --cert 3_application/certs/httpbin.example.com.cert.pemcat &lt;&lt;EOF | istioctl replace -f -apiVersion: networking.istio.io/v1alpha3kind: Gatewaymetadata: name: httpbin-gatewayspec: selector: istio: ingressgateway # use istio default ingress gateway servers: - port: number: 80 name: http protocol: HTTP hosts: - \"httpbin.example.com\" - port: number: 443 name: https protocol: HTTPS tls: mode: SIMPLE serverCertificate: /etc/istio/ingressgateway-certs/tls.crt privateKey: /etc/istio/ingressgateway-certs/tls.key hosts: - \"httpbin.example.com\"EOF# validate 200curl --resolve httpbin.example.com:$SECURE_INGRESS_PORT:$INGRESS_HOST -HHost:httpbin.example.com -I -k https://httpbin.example.com:$SECURE_INGRESS_PORT/status/200 Egress 流量默认情况下，Istio 接管了容器的内外网流量，从容器内部无法访问 Kubernetes 集群外的服务。可以通过 ServiceEntry 为需要的容器开放 Egress 访问，如$ cat &lt;&lt;EOF | istioctl create -f -apiVersion: networking.istio.io/v1alpha3kind: ServiceEntrymetadata: name: httpbin-extspec: hosts: - httpbin.org ports: - number: 80 name: http protocol: HTTPEOF$ cat &lt;&lt;EOF | istioctl create -f -apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata: name: httpbin-extspec: hosts: - httpbin.org http: - timeout: 3s route: - destination: host: httpbin.org weight: 100EOF 需要注意的是 ServiceEntry 仅支持 HTTP、TCP 和 HTTPS，对于其他协议需要通过 –includeIPRanges 的方式设置 IP 地址范围，如helm template @install/kubernetes/helm/istio@ --name istio --namespace istio-system --set global.proxy.includeIPRanges=\"10.0.0.1/24\" -x @templates/sidecar-injector-configmap.yaml@ | kubectl apply -f - 流量镜像cat &lt;&lt;EOF | istioctl replace -f -apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata: name: httpbinspec: hosts: - httpbin http: - route: - destination: host: httpbin subset: v1 weight: 100 mirror: host: httpbin subset: v2EOF 参考文档istio官方文档istio流量管理","tags":[{"name":"service Mesh","slug":"service-Mesh","permalink":"https://www.zhengyuyan.com/tags/service-Mesh/"},{"name":"istio","slug":"istio","permalink":"https://www.zhengyuyan.com/tags/istio/"}]},{"title":"istio官方示例bookinfo","date":"2018-07-17T13:38:19.000Z","path":"201807/17/bookinfo/","text":"官方bookinfo示例bookinfo显示有关书籍的信息，类似于在线书店的单个商品。页面上显示的是书籍，书籍详细信息（ISBN，页数等）以及一些书评。 Bookinfo应用程序分为四个独立的微服务： productpage。productpage微服务调用详细信息并查看微服务以填充页面。 details。details微服务包含书籍信息。 reviews。reviews微服务包含书评。它还称为评级微服务。 ratings。ratings微服务包含伴随书评的书籍排名信息。 reviews微服务有3个版本： 版本v1不会调用评级服务。 版本v2调用评级服务，并将每个评级显示为1到5个黑色星。 版本v3调用评级服务，并将每个评级显示为1到5个红星。 应用程序的端到端架构如下所示。 部署应用程序使用Istio不需要更改应用程序本身。相反，我们只需要在启用Istio的环境中配置和运行服务，并在每个服务旁边注入Envoy边车。所需的命令和配置因运行时环境而异，但在所有情况下，生成的部署将如下所示： 创建istio-app命名空间kubectl create namespace istio-app 将istio-app命名空间设置为自动注入标签kubectl label namespace istio-app istio-injection=enabled 执行kubectl apply -f samples/bookinfo/kube/bookinfo.yaml 部署好的productpage会自动注入sideCar 为程序定义网关入口istioctl create -f gateway/gateway.yaml -n istio-app apiVersion: networking.istio.io/v1alpha3kind: Gatewaymetadata: name: istio-gatewayspec: selector: istio: ingressgateway # use istio default controller servers: - port: number: 80 name: http protocol: HTTP hosts: - \"bookinfo.example.com\" 创建VirtualService apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata: name: bookinfospec: hosts: - \"bookinfo.example.com\" gateways: - istio-gateway http: - match: - uri: exact: /productpage - uri: exact: /login - uri: exact: /logout - uri: prefix: /api/v1/products route: - destination: host: productpage.istio-app.svc.cluster.local port: number: 9080 参考文档isito官方示例","tags":[{"name":"service Mesh","slug":"service-Mesh","permalink":"https://www.zhengyuyan.com/tags/service-Mesh/"},{"name":"istio","slug":"istio","permalink":"https://www.zhengyuyan.com/tags/istio/"}]},{"title":"istio 安装(二)","date":"2018-07-17T13:28:42.000Z","path":"201807/17/istio-install/","text":"istio安装istio官网安装提供了多种方法，因为集群中包含helm，所以选择用helm安装istio 下载istio release(目前版本为0.8.0) 命令行执行helm install install/kubernetes/helm/istio --name istio --namespace istio-system(此命令采取自动注入sideCar) istio的helm的value.yaml文件如下:# Use --set or additional values.yaml file to configure settings.# This file no longer uses sed, updateVersions.sh or istio.VERSIONS# TODO: evaluate if we need individual overrides for each component version, istio# is not typically tested with a mix of versions. Only supported case is version upgrade.# Common settings.global: # Default repository for Istio images. # Releases are published to docker hub under 'istio' project. # Daily builds from prow are on gcr.io, and nightly builds from circle on # docker.io/istionightly hub: 192.168.30.100:8889/istio # Default tag for Istio images. # Should track latest released version in the branch. tag: 0.8.0 proxy: image: proxyv2 resources: requests: cpu: 100m memory: 128Mi # istio-sidecar-injector configmap stores configuration for sidecar injection. # This config map is used by istioctl kube-inject and the injector webhook. enableCoreDump: false serviceAccountName: default # used only if RBAC is not enabled replicaCount: 1 resources: requests: cpu: 100m memory: 128Mi # limits: # cpu: 100m # memory: 128Mi # istio egress capture whitelist # https://istio.io/docs/tasks/traffic-management/egress.html#calling-external-services-directly # example: includeIPRanges: \"172.30.0.0/16,172.20.0.0/16\" # would only capture egress traffic on those two IP Ranges, all other outbound traffic would # be allowed by the sidecar includeIPRanges: \"*\" excludeIPRanges: \"\" # istio ingress capture whitelist # examples: # Redirect no inbound traffic to Envoy: --includeInboundPorts=\"\" # Redirect all inbound traffic to Envoy: --includeInboundPorts=\"*\" # Redirect only selected ports: --includeInboundPorts=\"80,8080\" includeInboundPorts: \"*\" excludeInboundPorts: \"\" policy: enabled proxy_init: image: proxy_init # imagePullPolicy is applied to istio control plane components. # local tests require IfNotPresent, to avoid uploading to dockerhub. # TODO: Switch to Always as default, and override in the local tests. imagePullPolicy: IfNotPresent # Not recommended for user to configure this. Hyperkube image to use when creating custom resources hyperkube: repository: 192.168.30.100:8889/coreos/hyperkube tag: v1.7.6_coreos.0 # controlPlaneMtls enabled. Will result in delays starting the pods while secrets are # propagated, not recommended for tests. controlPlaneSecurityEnabled: false # Default mtls policy. If true, mtls between services will be enabled by default. mtls: # Default setting for service-to-service mtls. Can be set explicitly using # destination rules or service annotations. enabled: false # List of fully qualified services to exclude from mtls # TODO: add the templating. mtlsExcludedServices: - \"kubernetes.default.svc.cluster.local\" # create RBAC resources. Must be set for any cluster configured with rbac. rbacEnabled: true ## imagePullSecrets for all ServiceAccount. Must be set for any clustser configured with privte docker registry. # imagePullSecrets: # - name: \"private-registry-key\" # Default is 1 second refreshInterval: 10s # Enable multicluster operation. Must be set to true if multicluster operation # is desired. multicluster: enabled: false # Specify pod scheduling arch(amd64, ppc64le, s390x) and weight as follows: # 0 - Never scheduled # 1 - Least preferred # 2 - No preference # 3 - Most preferred arch: amd64: 2 s390x: 2 ppc64le: 2# Any customization for istio testing should be hereistiotesting: oneNameSpace: false## ingress configuration#ingress: enabled: true serviceAccountName: default autoscaleMin: 1 autoscaleMax: 1 resources: &#123;&#125;# limits:# cpu: 100m# memory: 128Mi# requests:# cpu: 100m# memory: 128Mi service: loadBalancerIP: \"10.100.100.20\" type: LoadBalancer #change to NodePort, ClusterIP or LoadBalancer if need be ports: - port: 80 name: http nodePort: 32000 - port: 443 name: https selector: istio: ingress## ingressgateway configuration#ingressgateway: enabled: true serviceAccountName: istio-ingressgateway-service-account autoscaleMin: 1 autoscaleMax: 1 resources: &#123;&#125;# limits:# cpu: 100m# memory: 128Mi# requests:# cpu: 100m# memory: 128Mi service: name: istio-ingressgateway #DNS addressible labels: istio: ingressgateway #namespace: istio-system loadBalancerIP: \"10.100.100.129\" type: LoadBalancer #change to NodePort, ClusterIP or LoadBalancer if need be ports: ## You can add custom gateway ports - port: 80 name: http nodePort: 31380 - port: 443 name: https nodePort: 31390 - port: 31400 name: tcp nodePort: 31400 deployment: labels: istio: ingressgateway #will be added to pods and service ports: - containerPort: 80 - containerPort: 443 - containerPort: 31400 secretVolumes: - name: ingressgateway-certs secretName: istio-ingressgateway-certs mountPath: /etc/istio/ingressgateway-certs## egressgateway configuration#egressgateway: enabled: true serviceAccountName: istio-egressgateway-service-account autoscaleMin: 1 autoscaleMax: 1 resources: &#123;&#125;# limits:# cpu: 100m# memory: 128Mi# requests:# cpu: 100m# memory: 128Mi service: name: istio-egressgateway #DNS addressible labels: istio: egressgateway #namespace: istio-system type: ClusterIP #change to NodePort or LoadBalancer if need be ports: ## You can add custom gateway ports - port: 80 name: http - port: 443 name: https deployment: labels: istio: egressgateway #will be added to pods and service ports: - containerPort: 80 - containerPort: 443 # secretVolumes: TODO # - name: someName # mountPath: somePath # secretName: someName## sidecar-injector webhook configuration#sidecarInjectorWebhook: enabled: true image: sidecar_injector## galley configuration#galley: enabled: false serviceAccountName: default replicaCount: 1 image: galley resources: &#123;&#125; # limits: # cpu: 100m # memory: 128Mi # requests: # cpu: 100m # memory: 128Mi## mixer configuration#mixer: enabled: true serviceAccountName: default # used only if RBAC is not enabled replicaCount: 1 image: mixer resources: &#123;&#125; # limits: # cpu: 100m # memory: 128Mi # requests: # cpu: 100m # memory: 128Mi prometheusStatsdExporter: repository: 192.168.30.100:8889/prom/statsd-exporter tag: latest resources: &#123;&#125;## pilot configuration#pilot: enabled: true serviceAccountName: default # used only if RBAC is not enabled replicaCount: 1 image: pilot resources: &#123;&#125; # limits: # cpu: 100m # memory: 128Mi # requests: # cpu: 100m # memory: 128Mi## security configuration#security: enabled: true serviceAccountName: default # used only if RBAC is not enabled replicaCount: 1 image: citadel resources: &#123;&#125; # limits: # cpu: 100m # memory: 128Mi # requests: # cpu: 100m # memory: 128Mi cleanUpOldCA: true## addons configuration#grafana: enabled: true replicaCount: 1 image: grafana service: name: http type: ClusterIP externalPort: 3000 internalPort: 3000 ingress: enabled: false # Used to create an Ingress record. hosts: - grafana.local annotations: # kubernetes.io/ingress.class: nginx # kubernetes.io/tls-acme: \"true\" tls: # Secrets must be manually created in the namespace. # - secretName: grafana-tls # hosts: # - grafana.local resources: &#123;&#125; # limits: # cpu: 100m # memory: 128Mi # requests: # cpu: 100m # memory: 128Miprometheus: enabled: true replicaCount: 1 image: repository: 192.168.30.100:8889/prom/prometheus tag: latest ingress: enabled: false # Used to create an Ingress record. #hosts: # - prometheus.local annotations: # kubernetes.io/ingress.class: nginx # kubernetes.io/tls-acme: \"true\" tls: # Secrets must be manually created in the namespace. # - secretName: prometheus-tls # hosts: # - prometheus.local resources: &#123;&#125; # limits: # cpu: 100m # memory: 128Mi # requests: # cpu: 100m # memory: 128Mi service: nodePort: enabled: false port: 32090servicegraph: enabled: true replicaCount: 1 image: servicegraph service: name: http type: ClusterIP externalPort: 8088 internalPort: 8088 ingress: enabled: false # Used to create an Ingress record. hosts: - servicegraph.local annotations: # kubernetes.io/ingress.class: nginx # kubernetes.io/tls-acme: \"true\" tls: # Secrets must be manually created in the namespace. # - secretName: servicegraph-tls # hosts: # - servicegraph.local resources: &#123;&#125; # limits: # cpu: 100m # memory: 128Mi # requests: # cpu: 100m # memory: 128Mi # prometheus addres prometheusAddr: http://prometheus:9090tracing: enabled: true jaeger: enabled: true memory: max_traces: 50000 replicaCount: 1 image: repository: 192.168.30.100:8889/jaegertracing/all-in-one tag: 1.5 service: name: http type: ClusterIP externalPort: 9411 internalPort: 9411 uiPort: 16686 ingress: enabled: false # Used to create an Ingress record. hosts: - zipkin.local annotations: # kubernetes.io/ingress.class: nginx # kubernetes.io/tls-acme: \"true\" tls: # Secrets must be manually created in the namespace. # - secretName: zipkin-tls # hosts: # - zipkin.local resources: &#123;&#125; # limits: # cpu: 100m # memory: 128Mi # requests: # cpu: 100m # memory: 128Mi 主要修改了镜像地址和将以些默认不安装的addon设置为安装(grafana,servicegraph,tracing)安装成功之后 istio svc 为了避免ingressgate-way所在的机子80端口被占用，特申请一台ingressgate-way的IP地址相同机子在dns里添加了主机域名 Mesh ExpansionIstio 还支持管理非 Kubernetes 管理的应用。此时，需要在应用所在的 VM 或者物理中部署 Istio，具体步骤请参考 https://istio.io/docs/setup/kubernetes/mesh-expansion.html。部署好后，就可以向 Istio 注册应用，如# istioctl register servicename machine-ip portname:portistioctl -n onprem register mysql 1.2.3.4 3306istioctl -n onprem register svc1 1.2.3.4 http:7000 Prometheus、Grafana 和 Zipkin等所有 Pod 启动后，可以通过 NodePort、负载均衡服务的外网 IP 或者 kubectl proxy 来访问这些服务或者创建一个istio的VirtualService。apiVersion: networking.istio.io/v1alpha3kind: Gatewaymetadata: name: istio-gatewayspec: selector: istio: ingressgateway # use istio default controller servers: - port: number: 80 name: http protocol: HTTP hosts: - \"prom.example.com\" - \"grafana.example.com\" - \"pilot.example.com\" - \"zipkin.example.com\"---apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata: name: grafanaspec: hosts: - \"grafana.example.com\" gateways: - istio-gateway http: - route: - destination: host: grafana.istio-system.svc.cluster.local port: number: 3000---apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata: name: promspec: hosts: - \"prom.example.com\" gateways: - istio-gateway http: - route: - destination: host: prometheus.istio-system.svc.cluster.local port: number: 9090--- 通过 http://grafana.example.com 访问 Grafana 服务 通过loabblancer访问jaeger-query,展示服务之间调用关系图 参考文档官方istio安装istio安装","tags":[{"name":"service Mesh","slug":"service-Mesh","permalink":"https://www.zhengyuyan.com/tags/service-Mesh/"},{"name":"istio","slug":"istio","permalink":"https://www.zhengyuyan.com/tags/istio/"}]},{"title":"istio简介(一)","date":"2018-07-17T13:17:51.000Z","path":"201807/17/istio-brief/","text":"Istio简介Service Mesh服务网格是一个基础设施层，功能在于处理服务间通信，职责是负责实现请求的可靠传递。在实践中，服务网格通常实现为轻量级网络代理，通常与应用程序部署在一起，但是对应用程序透明。 Istio是什么Istio是一个服务网格.Istio 是一个用来连接、管理和保护微服务的开放平台。Istio 提供一种简单的方式来为已部署的服务建立网络，该网络具有负载均衡、服务间认证、监控等功能，而不需要对服务的代码做任何改动。想要让服务支持 Istio，只需要在您的环境中部署一个特殊的 sidecar，使用 Istio 控制平面功能配置和管理代理，拦截微服务之间的所有网络通信。 Istio功能Istio 提供了一个完整的解决方案，通过为整个服务网格提供行为洞察和操作控制来满足微服务应用程序的多样化需求。它在服务网络中统一提供了许多关键功能： 流量管理。控制服务之间的流量和API调用的流向，使得调用更可靠，并使网络在恶劣情况下更加健壮。 服务身份和安全。为网格中的服务提供可验证身份，并提供保护服务流量的能力，使其可以在不同可信度的网络上流转。 策略执行。将组织策略应用于服务之间的互动，确保访问策略得以执行，资源在消费者之间良好分配。可以通过通过配置网格而不是修改应用程序代码来完成策略的更改。 遥测：了解服务之间的依赖关系，以及它们之间流量的本质和流向，从而提供快速识别问题的能力。 Istio体系结构Istio 服务网格逻辑上分为数据平面和控制平面。 数据平面由一组以sidecar方式部署的智能代理（Envoy）组成。这些代理可以调节和控制微服务及 Mixer 之间所有的网络通信。 控制平面负责管理和配置代理来路由流量。此外控制平面配置 Mixer 以实施策略和收集遥测数据。 Istio主要由Envoy、Pilot、Mixer三部分组成，整体结构如下： Envoy：以sidecar的形式和应用程序运行与同一个pod中，通过修改iptables来代理应用程序的所有出入流量 Pilot：接受系统管理员发出的指令或者规则，遥控所有Envoy的行为 Mixer：从Envoy处获取流量属性，根据自定义的属性匹配规则进行流量处理，如：流量限制、日志记录等 EnvoyIstio利用了Envoy的许多内置功能，例如动态服务发现，负载均衡，TLS termination，HTTP/2&amp;gRPC代理，熔断器，健康检查，基于百分比流量拆分的分段推出，故障注入和丰富的metrics。Envoy实现了过滤和路由、服务发现、健康检查，提供了具有弹性的负载均衡。它在安全上支持TLS，在通信方面支持gRPC. 概括说，Envoy 提供的是服务间网络通讯的能力，包括(以下均可支持TLS)： HTTP／1.1 HTTP/2 gRPC TCP 以及网络通讯直接相关的功能： 服务发现：从Pilot得到服务发现信息 过滤 负载均衡 健康检查 执行路由规则(Rule): 规则来自Polit,包括路由和目的地策略 加密和认证: TLS certs来自 istio-Auth Pilot(流量管理)Envoy在其中扮演的负责搬砖的民工角色, 而指挥Envoy工作的民工头就是Pilot模块.Pilot负责收集和验证配置并将其传播到各种Istio组件。它从Mixer和Envoy中抽取环境特定的实现细节，为他们提供独立于底层平台的用户服务的抽象表示。此外，流量管理规则（即通用4层规则和7层HTTP/gRPC路由规则）可以在运行时通过Pilot进行编程。每个Envoy实例根据其从Pilot获得的信息以及其负载均衡池中的其他实例的定期健康检查来维护 负载均衡信息，从而允许其在目标实例之间智能分配流量，同时遵循其指定的路由规则。Pilot负责在Istio服务网格中部署的Envoy实例的生命周期。 Pilot的架构 Envoy API负责和Envoy的通讯, 主要是发送服务发现信息和流量控制规则给Envoy Envoy提供服务发现，负载均衡池和路由表的动态更新的API。这些API将istio和Envoy的实现解耦。(另外,也使得 Linkerd 之类的其他服务网络实现得以平滑接管Envoy) Polit 定了一个抽象模型, 以从特定平台细节中解耦, 为跨平台提供基础. Platform Adapter则是这个抽象模型的现实实现版本, 用于对接外部的不同平台 最后是 Rules API, 提供接口给外部调用以管理 Pilot, 包括命令行工具istioctl以及未来可能出现的第三方管理界面 pilot功能基于上述的架构设计, pilot提供以下重要功能: 请求路由 服务发现和负载均衡 故障处理 故障注入 规则配置 Mixer Mixer负责在服务网格上执行访问控制和使用策略，并收集Envoy代理和其他服务的遥测数据。 Mixer的设计背景我们的系统通常会基于大量的基础设施而构建, 这些基础设施的后端服务为业务服务提供各种支持功能。包括访问控制系统，遥测捕获系统，配额执行系统，计费系统等。在传统设计中, 服务直接与这些后端系统集成，容易产生硬耦合.在istio中,为了避免应用程序的微服务和基础设施的后端服务之间的耦合, 提供了 Mixer 作为两者的通用中介层: Mixer的功能Mixer 提供三个核心功能： 前提条件检查。允许服务在响应来自服务消费者的传入请求之前验证一些前提条件。前提条件包括认证，黑白名单，ACL检查等等。 配额管理。使服务能够在多个维度上分配和释放配额。典型例子如限速。 遥测报告。使服务能够上报日志和监控。在Istio内，Envoy重度依赖Mixer。 Istio-AuthIstio-Auth提供强大的服务到服务和终端用户认证，使用交互TLS，内置身份和凭据管理。它可用于升级服务网格中的未加密流量，并为运维人员提供基于服务身份而不是网络控制实施策略的能力。 auth的架构其中包括三个组件：身份，密钥管理和通信安全。 参考文档istio官网服务网格新生代-Istio(敖小剑)istio简介","tags":[{"name":"service Mesh","slug":"service-Mesh","permalink":"https://www.zhengyuyan.com/tags/service-Mesh/"},{"name":"istio","slug":"istio","permalink":"https://www.zhengyuyan.com/tags/istio/"}]},{"title":"etcd操作","date":"2018-06-29T09:22:39.000Z","path":"201806/29/etcd操作/","text":"helm删除应用,kubernetes dashbord上显示的相关pod还在,利用kubectl命令查询报Error from server (NotFound): pods &quot;istio-pilot-9b8bb4dcb-k2knj&quot; not found今天利用helm去部署一个应用， 因为一些问题想删掉部署的应用。 利用helm执行了删除操作后，dashbord中有几个pod显示异常,未被删除。 用kubectl去查询pod, 查询结果显示Error from server (NotFound): pods &quot;istio-pilot-9b8bb4dcb-k2knj&quot; not found。 dashboard刷新了几次 相关异常pod还在。 为了真正的删除资源，就操作etcd了。 连接etcd所在服务器执行ectdctl --help,然后执行etcdctl ls结果 然后执行了export ETCDCTL_API=3。 然后etcdctl get /registry/deployments/default --prefix --keys-only 最后删除相关异常pod etcdctl del /registry/pods/istio-system/istio-sidecar-injector-7889c4fdf5-gnbpketcdctl del /registry/pods/istio-system/istio-pilot-db45c47d9-bzt9retcdctl del /registry/pods/istio-system/istio-sidecar-injector-645c89bc64-fh298","tags":[{"name":"etcd","slug":"etcd","permalink":"https://www.zhengyuyan.com/tags/etcd/"}]}]